# 5-1 面向对象特征之二：继承性
## 5.1 面向对象特征之二：继承性(inheritance)
* 为什么要有继承？
	* 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。
* 此处的多个类称为子类(派生类)，单独的这个类称为父类(基类
或超类)。可以理解为:“子类 is a 父类”
* 类继承语法规则:
class Subclass extends SuperClass{ }
* 作用：
	* 继承的出现减少了代码冗余，提高了代码的复用性。
	* 继承的出现，更有利于功能的扩展。
	* 继承的出现让类与类之间产生了关系，提供了多态的前提。

![title](https://raw.githubusercontent.com/XJZ-0707/imge/master/gitnote/2019/09/17/%E7%BB%A7%E6%89%BF%E8%A7%84%E5%88%99-1568723503726.jpg)

![title](https://raw.githubusercontent.com/XJZ-0707/imge/master/gitnote/2019/09/17/%E7%BB%A7%E6%89%BF2-1568723591357.jpg)

# 5-2 方法的重写(override/overwrite)
## 5.2 方法的重写(override/overwrite)
* 定义：在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。
* 要求：
	1. 子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表
	2. 子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型
	3. 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限子类不能重写父类中声明为private权限的方法
	4. 子类方法抛出的异常不能大于父类被重写方法的异常
* 重写的规定：
	方法的声明： 权限修饰符  返回值类型  方法名(形参列表) throws 异常的类型{
								//方法体
		 					}
约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法
		① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同
		② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符
		      	>特殊情况：子类不能重写父类中声明为private权限的方法
		③ 返回值类型：
		      	>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void
		      	>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类
		     	>父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)
		④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）

# 5-4 关键字：super
## 关键字：super
* 在Java类中使用super来调用父类中的指定操作：
	* super可用于访问父类中定义的属性
	* super可用于调用父类中定义的成员方法
	* super可用于在子类构造器中调用父类的构造器

* 注意：
	 尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员
	 super的追溯不仅限于直接父类
	 super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识

* 调用父类的构造器
	* 子类中所有的构造器默认都会访问父类中空参数的构造器
	* 当父类中没有空参数的构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表)语句指定调用本类或者父类中相应的构造器。同时，只能”二选一”，且必须放在构造器的首行
	* 如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错
![title](https://raw.githubusercontent.com/XJZ-0707/imge/master/gitnote/2019/09/18/this%E5%92%8Csuper%E7%9A%84%E5%8C%BA%E5%88%AB-1568779172933.jpg)

# 5-6 面向对象特征之三：多态性
## 面向对象特征之三：多态性
* 多态性，是面向对象中最重要的概念，在Java中的体现：
	* 对象的多态性：父类的引用指向子类的对象
	* 可以直接应用在抽象类和接口上

* Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。简称：编译时，看左边；运行时，看右边。
	* 若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)
多态情况下，
“看左边”
：看的是父类的引用（父类中不具备子类特有的方法）
“看右边”
：看的是子类的对象（实际运行的是子类重写父类的方法）

