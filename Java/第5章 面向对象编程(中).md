# 5-1 面向对象特征之二：继承性
## 5.1 面向对象特征之二：继承性(inheritance)
* 为什么要有继承？
	* 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。
* 此处的多个类称为子类(派生类)，单独的这个类称为父类(基类
或超类)。可以理解为:“子类 is a 父类”
* 类继承语法规则:
class Subclass extends SuperClass{ }
* 作用：
	* 继承的出现减少了代码冗余，提高了代码的复用性。
	* 继承的出现，更有利于功能的扩展。
	* 继承的出现让类与类之间产生了关系，提供了多态的前提。

![title](https://raw.githubusercontent.com/XJZ-0707/imge/master/gitnote/2019/09/17/%E7%BB%A7%E6%89%BF%E8%A7%84%E5%88%99-1568723503726.jpg)

![title](https://raw.githubusercontent.com/XJZ-0707/imge/master/gitnote/2019/09/17/%E7%BB%A7%E6%89%BF2-1568723591357.jpg)

# 5-2 方法的重写(override/overwrite)
## 5.2 方法的重写(override/overwrite)
* 定义：在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。
* 要求：
	1. 子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表
	2. 子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型
	3. 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限子类不能重写父类中声明为private权限的方法
	4. 子类方法抛出的异常不能大于父类被重写方法的异常
* 重写的规定：
	方法的声明： 权限修饰符  返回值类型  方法名(形参列表) throws 异常的类型{
								//方法体
		 					}
约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法
		① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同
		② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符
		      	>特殊情况：子类不能重写父类中声明为private权限的方法
		③ 返回值类型：
		      	>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void
		      	>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类
		     	>父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)
		④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）

# 5-4 关键字：super
## 关键字：super
* 在Java类中使用super来调用父类中的指定操作：
	* super可用于访问父类中定义的属性
	* super可用于调用父类中定义的成员方法
	* super可用于在子类构造器中调用父类的构造器

* 注意：
	 尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员
	 super的追溯不仅限于直接父类
	 super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识

* 调用父类的构造器
	* 子类中所有的构造器默认都会访问父类中空参数的构造器
	* 当父类中没有空参数的构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表)语句指定调用本类或者父类中相应的构造器。同时，只能”二选一”，且必须放在构造器的首行
	* 如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错
![title](https://raw.githubusercontent.com/XJZ-0707/imge/master/gitnote/2019/09/18/this%E5%92%8Csuper%E7%9A%84%E5%8C%BA%E5%88%AB-1568779172933.jpg)

# 5-6 面向对象特征之三：多态性
## 面向对象特征之三：多态性
* 多态性，是面向对象中最重要的概念，在Java中的体现：
	* 对象的多态性：父类的引用指向子类的对象
	* 可以直接应用在抽象类和接口上

* Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。简称：编译时，看左边；运行时，看右边。
	* 若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)
	* 多态情况下，“看左边”：看的是父类的引用（父类中不具备子类特有的方法）
	“看右边”：看的是子类的对象（实际运行的是子类重写父类的方法）

* 对象的多态 —在Java中,子类的对象可以替代父类的对象使用
	* 一个变量只能有一种确定的数据类型
	* 一个引用类型变量可能指向(引用)多种不同类型的对象
```java
Person p = new Student();
Object o = new Person();//Object类型的变量o，指向Person类型的对象
o = new Student(); //Object类型的变量o，指向Student类型的对象
```

* 子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型(upcasting)。

* 一个引用类型变量如果声明为父类的类型，但实际引用的是子类
对象，那么该变量就不能再访问子类中添加的属性和方法
Student m = new Student();
m.school = “pku”; //合法,Student类有school成员变量
Person e = new Student();
e.school = “pku”; //非法,Person类没有school成员变量
属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编译错误。


* 方法声明的形参类型为父类类型，可以使用子类的对象作为实参调用该方法
```java
public class Test {
public void method(Person e) {
// ……
e.getInfo();
}
public static void main(Stirng args[]) {
Test t = new Test();
Student m = new Student();
t.method(m); // 子类的对象m传送给父类类型的参数e
}
}


```

## 虚拟方法调用(Virtual Method Invocation)
* 正常的方法调用
```java
Person e = new Person();
e.getInfo();
Student e = new Student();
e.getInfo();

```
* 虚拟方法调用(多态情况下)
子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。
```java

Person e = new Student();
e.getInfo(); //调用Student类的getInfo()方法
```
* 编译时类型和运行时类型
编译时e为Person类型，而方法的调用是在运行时确定的，所以调用是Student类的getInfo()方法。——动态绑定
```java
package com.day12.java4;

import java.sql.Connection;


//多态性的使用举例一：
public class AnimalTest {
	
	public static void main(String[] args) {
		
		AnimalTest test = new AnimalTest();
		test.func(new Dog());
		
		
		test.func(new Cat());
	}
	
	public void func(Animal animal){//Animal animal = new Dog();
		animal.eat();
		animal.shout();
		
		if(animal instanceof Dog){
			Dog d = (Dog)animal;
			d.watchDoor();
		}
	}
	
//	public void func(Dog dog){
//		dog.eat();
//		dog.shout();
//	}
//	public void func(Cat cat){
//		cat.eat();
//		cat.shout();
//	}
}


class Animal{
	
	
	public void eat(){
		System.out.println("动物：进食");
	}
	
	public void shout(){
		System.out.println("动物：叫");
	}
	
	
}

class Dog extends Animal{
	public void eat(){
		System.out.println("狗吃骨头");
	}
	
	public void shout(){
		System.out.println("汪！汪！汪！");
	}
	
	public void watchDoor(){
		System.out.println("看门");
	}
}
class Cat extends Animal{
	public void eat(){
		System.out.println("猫吃鱼");
	}
	
	public void shout(){
		System.out.println("喵！喵！喵！");
	}
}

//举例二：

class Order{
	
	public void method(Object obj){
		
	}
}

//举例三：
class Driver{
	
	public void doData(Connection conn){//conn = new MySQlConnection(); / conn = new OracleConnection();
		//规范的步骤去操作数据
//		conn.method1();
//		conn.method2();
//		conn.method3();
		
	}
	
}


```



## 小结：方法的重载与重写
1. 二者的定义细节：略
2. 从编译和运行的角度看：
(1) 重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。**它们的调用地址在编译期就绑定了**。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，**这称为“早绑定”或“静态绑定”**；
(2) 而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。
引用一句Bruce Eckel的话：**“不要犯傻，如果它不是晚绑定，它就不是多态。”**

## 多态小结
* 多态作用：
	* 提高了代码的通用性，常称作接口重用
*  前提：
	*  需要存在继承或者实现关系
	* 有方法的重写
* 成员方法：
	* 编译时：要查看引用变量所声明的类中是否有所调用的方法。
	* 运行时：调用实际new的对象所属的类中的重写方法。
*  成员变量：
	* 不具备多态性，只看引用变量所声明的类。

## instanceof 操作符
* **x instanceof A：检验x是否为类A的对象，返回值为boolean型。**
	*  要求x所属的类与类A必须是子类和父类的关系，否则编译错误。
	*  如果x属于类A的子类B，x instanceof A值也为true。
```java
public class Person extends Object {…}
public class Student extends Person {…}
public class Graduate extends Person {…}
-------------------------------------------------------------------
public void method1(Person e) {
if (e instanceof Person)
// 处理Person类及其子类对象
if (e instanceof Student)
//处理Student类及其子类对象
if (e instanceof Graduate)
//处理Graduate类及其子类对象
}

```

```java
//对象类型转换举例


```
